---
title: "IndividualPondModels_Forecasts45_CR"
author: "Amaryllis Adey"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
```

Goal of this code is to fit a model to the observational data for each of the ponds in the Yakutat Forelands

# Modeling the Observational Data for the Copper River Delta Ponds

Looping through each pond individually because the for loop to do this was more complicated than I could figure out in the time before SFS

# Set up the working space for the analysis

## Load in packages

```{r}
library(rjags)
library(daymetr)
library(ecoforecastR)
library(dplyr)
library(lubridate)
library(zoo)
library(ggplot2)
library(hydroGOF)
```

## Start by loading in the Copper River Delta mean data set

```{r}
CR_Temps <- read.csv("CR_45SNAPForecast.csv", header=TRUE)

library(dplyr)
# remove the first column here and change the column for Date to date

CR_Temps <- CR_Temps[,-1]
head(CR_Temps)
```

## Separate the data into the air temp and the water temp data

```{r}
CR_AirTemp <- CR_Temps %>%
  select(date, Airport, Air_MonthAvg, std, precision, Region)

CR_WaterTemp <- CR_Temps %>%
  select(date, std, precision, BVS, CAB, TIN, SQR, CAN, EYS, TIS, WDD, RHM)
```

## Going to attempt to plot the water temperature and the air temperature over time

Looks a bit odd here because it has the 2012-2100 pond temps but only the 2012-2020 water temps

```{r}
head(CR_Temps)

# # plotting this --> shows up as 'blank'
# ggplot(CR_Temps)+
#   geom_line(data = CR_Temps, aes(x = date, y = Air_MonthAvg, color = 'red', linetype = "solid"))+
#   geom_line(data = CR_Temps, aes(x = date, y = UBP4, color = 'blue', linetype = "dashed"))

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)

# Reshape the data from wide to long format
CR_Temps_long <- CR_Temps %>%
  pivot_longer(cols = c(Air_MonthAvg, BVS, CAB, TIN, SQR, CAN, EYS, TIS, WDD, RHM),
               names_to = "variable",
               values_to = "value")

# Check the structure of the reshaped data
str(CR_Temps_long)

# Create the plot
# Create the plot
CR_PondTemp <- ggplot(CR_Temps_long, aes(x = as.Date(date), y = value, color = variable)) +
  geom_line(data = filter(CR_Temps_long, variable == "Air_MonthAvg"), color = "black") +  
  geom_line(data = filter(CR_Temps_long, variable != "Air_MonthAvg")) +  
  labs(title = "CR Pond Water Temperature Over Time",
       x = "Date",
       y = "Value",
       color = "Variable") +
  theme_minimal()
CR_PondTemp


# Save the plot
ggsave("Output/GeoSNAP/CR_PondTemp.png", plot = CR_PondTemp, width = 8, height = 6)

```

# Starting the Analysis

## Part 1 - Pulling out the data that we want
-Linear air-water temperature relationship with only one pond here

# BVS

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- BVS
y <- CR_WaterTemp$BVS
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$BVS
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
BVS_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we can use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
BVS_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(BVS_out_params)
gelman.diag(BVS_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starting from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(BVS_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it can be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  BVS_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you can use this data frame with ggplot2
BVSModelPlot <- ggplot(BVS_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#E41A1C")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = BVS)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
BVSModelPlot

BVSModelErrorPlot <- ggplot(BVS_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#E41A1C") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = BVS)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
BVSModelErrorPlot

ggsave("Output/GeoSNAP/BVS_45_ModelPlot.jpeg", plot = BVSModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/BVS_45_ModelErrorPlot.jpeg", plot = BVSModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
BVSMod <- BVS_OutputCheck
write.csv(BVSMod, file = "BVSMod_45.csv", row.names = F)
BVS_NSE <- NSE(BVSMod$`50%`, BVS_OutputCheck$BVS, na.rm = TRUE)
BVS_NSE

# filter to data before 2020 for the obs graph?
BVSMod_total <- BVSMod

BVSMod <- BVSMod %>%
  filter(date < "2021-01-01")
range(BVSMod$date)
avgBVS2010 <- mean(BVSMod$`50%`)
avgBVS2010
stdBVS2010 <- sd(BVSMod$`50%`)
stdBVS2010

BVSModelErrorPlot <- ggplot(BVSMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#E41A1C") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = BVS)) +
  ggtitle("BVS - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.997")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
BVSModelErrorPlot

ggsave("Output/GeoSNAP/BVS_ObsModelPlot_45.jpeg", plot = BVSModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we can zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
BVS_2030 <- BVS_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgBVS2030 <- mean(BVS_2030$`50%`)
avgBVS2030
stdBVS2030 <- sd(BVS_2030$`50%`)
stdBVS2030

# Now you can use this data frame with ggplot2
BVS_2030_ModelPlot <- ggplot(BVS_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = BVS)) +
  ggtitle("BVS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
BVS_2030_ModelPlot

BVS_2030_ModelErrorPlot <- ggplot(BVS_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#E41A1C") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = BVS)) +
  ggtitle("BVS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
BVS_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/BVS_2030_45_ModelPlot.jpeg", plot = BVS_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/BVS_2030_45_ModelErrorPlot.jpeg", plot = BVS_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
BVS_2060 <- BVS_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgBVS2060 <- mean(BVS_2060$`50%`)
avgBVS2060
stdBVS2060 <- sd(BVS_2060$`50%`)
stdBVS2060

# Now you can use this data frame with ggplot2
BVS_2060_ModelPlot <- ggplot(BVS_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = BVS)) +
  ggtitle("BVS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
BVS_2060_ModelPlot

BVS_2060_ModelErrorPlot <- ggplot(BVS_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#E41A1C") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = BVS)) +
  ggtitle("BVS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
BVS_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/BVS_2060_45_ModelPlot.jpeg", plot = BVS_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/BVS_2060_45_ModelErrorPlot.jpeg", plot = BVS_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
BVS_2090 <- BVS_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgBVS2090 <- mean(BVS_2090$`50%`)
avgBVS2090
stdBVS2090 <- sd(BVS_2090$`50%`)
stdBVS2090

# Now you can use this data frame with ggplot2
BVS_2090_ModelPlot <- ggplot(BVS_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = BVS)) +
  ggtitle("BVS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
BVS_2090_ModelPlot

BVS_2090_ModelErrorPlot <- ggplot(BVS_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#E41A1C") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = BVS)) +
  ggtitle("BVS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
BVS_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/BVS_2090_45_ModelPlot.jpeg", plot = BVS_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/BVS_2090_45_ModelErrorPlot.jpeg", plot = BVS_2090_ModelErrorPlot, width = 8, height = 6)
```
# CAB

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- CAB
y <- CR_WaterTemp$CAB
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$CAB
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
CAB_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we can use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
CAB_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(CAB_out_params)
gelman.diag(CAB_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starting from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(CAB_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it can be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  CAB_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you can use this data frame with ggplot2
CABModelPlot <- ggplot(CAB_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#377EBB")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAB)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
CABModelPlot

CABModelErrorPlot <- ggplot(CAB_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#377EBB") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAB)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
CABModelErrorPlot

ggsave("Output/GeoSNAP/CAB_45_ModelPlot.jpeg", plot = CABModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAB_45_ModelErrorPlot.jpeg", plot = CABModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
CABMod <- CAB_OutputCheck
write.csv(CABMod, file = "CABMod_45.csv", row.names = F)
CAB_NSE <- NSE(CABMod$`50%`, CAB_OutputCheck$CAB, na.rm = TRUE)
CAB_NSE

# filter to data before 2020 for the obs graph?
CABMod_total <- CABMod

CABMod <- CABMod %>%
  filter(date < "2021-01-01")
range(CABMod$date)
avgCAB2010 <- mean(CABMod$`50%`)
avgCAB2010
stdCAB2010 <- sd(CABMod$`50%`)
stdCAB2010

CABModelErrorPlot <- ggplot(CABMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#377EBB") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAB)) +
  ggtitle("CAB - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.980")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
CABModelErrorPlot

ggsave("Output/GeoSNAP/CAB_ObsModelPlot_45.jpeg", plot = CABModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we can zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
CAB_2030 <- CAB_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgCAB2030 <- mean(CAB_2030$`50%`)
avgCAB2030
stdCAB2030 <- sd(CAB_2030$`50%`)
stdCAB2030

# Now you can use this data frame with ggplot2
CAB_2030_ModelPlot <- ggplot(CAB_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAB)) +
  ggtitle("CAB - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAB_2030_ModelPlot

CAB_2030_ModelErrorPlot <- ggplot(CAB_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#377EBB") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAB)) +
  ggtitle("CAB - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAB_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/CAB_2030_45_ModelPlot.jpeg", plot = CAB_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAB_2030_45_ModelErrorPlot.jpeg", plot = CAB_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
CAB_2060 <- CAB_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgCAB2060 <- mean(CAB_2060$`50%`)
avgCAB2060
stdCAB2060 <- sd(CAB_2060$`50%`)
stdCAB2060

# Now you can use this data frame with ggplot2
CAB_2060_ModelPlot <- ggplot(CAB_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAB)) +
  ggtitle("CAB - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAB_2060_ModelPlot

CAB_2060_ModelErrorPlot <- ggplot(CAB_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#377EBB") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAB)) +
  ggtitle("CAB - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAB_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/CAB_2060_45_ModelPlot.jpeg", plot = CAB_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAB_2060_45_ModelErrorPlot.jpeg", plot = CAB_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
CAB_2090 <- CAB_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgCAB2090 <- mean(CAB_2090$`50%`)
avgCAB2090
stdCAB2090 <- sd(CAB_2090$`50%`)
stdCAB2090

# Now you can use this data frame with ggplot2
CAB_2090_ModelPlot <- ggplot(CAB_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAB)) +
  ggtitle("CAB - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAB_2090_ModelPlot

CAB_2090_ModelErrorPlot <- ggplot(CAB_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#377EBB") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAB)) +
  ggtitle("CAB - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAB_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/CAB_2090_45_ModelPlot.jpeg", plot = CAB_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAB_2090_45_ModelErrorPlot.jpeg", plot = CAB_2090_ModelErrorPlot, width = 8, height = 6)
```

# CAN

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- CAN
y <- CR_WaterTemp$CAN
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$CAN
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
CAN_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we can use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
CAN_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(CAN_out_params)
gelman.diag(CAN_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starting from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(CAN_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it can be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  CAN_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you can use this data frame with ggplot2
CANModelPlot <- ggplot(CAN_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#4DAF4A")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAN)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
CANModelPlot

CANModelErrorPlot <- ggplot(CAN_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#4DAF4A") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAN)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
CANModelErrorPlot

ggsave("Output/GeoSNAP/CAN_45_ModelPlot.jpeg", plot = CANModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAN_45_ModelErrorPlot.jpeg", plot = CANModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
CANMod <- CAN_OutputCheck
write.csv(CANMod, file = "CANMod_45.csv", row.names = F)
CAN_NSE <- NSE(CANMod$`50%`, CAN_OutputCheck$CAN, na.rm = TRUE)
CAN_NSE

# filter to data before 2020 for the obs graph?
CANMod_total <- CANMod

CANMod <- CANMod %>%
  filter(date < "2021-01-01")
range(CANMod$date)
avgCAN2010 <- mean(CANMod$`50%`)
avgCAN2010
stdCAN2010 <- sd(CANMod$`50%`)
stdCAN2010

CANModelErrorPlot <- ggplot(CANMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#4DAF4A") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAN)) +
  ggtitle("CAN - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.999")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
CANModelErrorPlot

ggsave("Output/GeoSNAP/CAN_ObsModelPlot_45.jpeg", plot = CANModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we can zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
CAN_2030 <- CAN_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgCAN2030 <- mean(CAN_2030$`50%`)
avgCAN2030
stdCAN2030 <- sd(CAN_2030$`50%`)
stdCAN2030

# Now you can use this data frame with ggplot2
CAN_2030_ModelPlot <- ggplot(CAN_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAN)) +
  ggtitle("CAN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAN_2030_ModelPlot

CAN_2030_ModelErrorPlot <- ggplot(CAN_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#4DAF4A") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAN)) +
  ggtitle("CAN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAN_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/CAN_2030_45_ModelPlot.jpeg", plot = CAN_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAN_2030_45_ModelErrorPlot.jpeg", plot = CAN_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
CAN_2060 <- CAN_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgCAN2060 <- mean(CAN_2060$`50%`)
avgCAN2060
stdCAN2060 <- sd(CAN_2060$`50%`)
stdCAN2060

# Now you can use this data frame with ggplot2
CAN_2060_ModelPlot <- ggplot(CAN_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAN)) +
  ggtitle("CAN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAN_2060_ModelPlot

CAN_2060_ModelErrorPlot <- ggplot(CAN_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#4DAF4A") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAN)) +
  ggtitle("CAN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAN_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/CAN_2060_45_ModelPlot.jpeg", plot = CAN_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAN_2060_45_ModelErrorPlot.jpeg", plot = CAN_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
CAN_2090 <- CAN_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgCAN2090 <- mean(CAN_2090$`50%`)
avgCAN2090
stdCAN2090 <- sd(CAN_2090$`50%`)
stdCAN2090

# Now you can use this data frame with ggplot2
CAN_2090_ModelPlot <- ggplot(CAN_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = CAN)) +
  ggtitle("CAN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAN_2090_ModelPlot

CAN_2090_ModelErrorPlot <- ggplot(CAN_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#4DAF4A") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = CAN)) +
  ggtitle("CAN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
CAN_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/CAN_2090_45_ModelPlot.jpeg", plot = CAN_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/CAN_2090_45_ModelErrorPlot.jpeg", plot = CAN_2090_ModelErrorPlot, width = 8, height = 6)
```

# EYS

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- EYS
y <- CR_WaterTemp$EYS
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$EYS
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
EYS_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we EYS use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
EYS_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(EYS_out_params)
gelman.diag(EYS_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starting from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(EYS_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it EYS be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  EYS_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you EYS use this data frame with ggplot2
EYSModelPlot <- ggplot(EYS_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#984EA3")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = EYS)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
EYSModelPlot

EYSModelErrorPlot <- ggplot(EYS_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#984EA3") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = EYS)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
EYSModelErrorPlot

ggsave("Output/GeoSNAP/EYS_45_ModelPlot.jpeg", plot = EYSModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/EYS_45_ModelErrorPlot.jpeg", plot = EYSModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
EYSMod <- EYS_OutputCheck
write.csv(EYSMod, file = "EYSMod_45.csv", row.names = F)
EYS_NSE <- NSE(EYSMod$`50%`, EYS_OutputCheck$EYS, na.rm = TRUE)
EYS_NSE

# filter to data before 2020 for the obs graph?
EYSMod_total <- EYSMod

EYSMod <- EYSMod %>%
  filter(date < "2021-01-01")
range(EYSMod$date)
avgEYS2010 <- mean(EYSMod$`50%`)
avgEYS2010
stdEYS2010 <- sd(EYSMod$`50%`)
stdEYS2010

EYSModelErrorPlot <- ggplot(EYSMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#984EA3") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = EYS)) +
  ggtitle("EYS - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.999")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
EYSModelErrorPlot

ggsave("Output/GeoSNAP/EYS_ObsModelPlot_45.jpeg", plot = EYSModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we EYS zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
EYS_2030 <- EYS_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgEYS2030 <- mean(EYS_2030$`50%`)
avgEYS2030
stdEYS2030 <- sd(EYS_2030$`50%`)
stdEYS2030

# Now you can use this data frame with ggplot2
EYS_2030_ModelPlot <- ggplot(EYS_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = EYS)) +
  ggtitle("EYS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
EYS_2030_ModelPlot

EYS_2030_ModelErrorPlot <- ggplot(EYS_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#984EA3") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = EYS)) +
  ggtitle("EYS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
EYS_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/EYS_2030_45_ModelPlot.jpeg", plot = EYS_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/EYS_2030_45_ModelErrorPlot.jpeg", plot = EYS_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
EYS_2060 <- EYS_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgEYS2060 <- mean(EYS_2060$`50%`)
avgEYS2060
stdEYS2060 <- sd(EYS_2060$`50%`)
stdEYS2060

# Now you can use this data frame with ggplot2
EYS_2060_ModelPlot <- ggplot(EYS_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = EYS)) +
  ggtitle("EYS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
EYS_2060_ModelPlot

EYS_2060_ModelErrorPlot <- ggplot(EYS_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#984EA3") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = EYS)) +
  ggtitle("EYS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
EYS_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/EYS_2060_45_ModelPlot.jpeg", plot = EYS_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/EYS_2060_45_ModelErrorPlot.jpeg", plot = EYS_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
EYS_2090 <- EYS_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgEYS2090 <- mean(EYS_2090$`50%`)
avgEYS2090
stdEYS2090 <- sd(EYS_2090$`50%`)
stdEYS2090

# Now you can use this data frame with ggplot2
EYS_2090_ModelPlot <- ggplot(EYS_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = EYS)) +
  ggtitle("EYS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
EYS_2090_ModelPlot

EYS_2090_ModelErrorPlot <- ggplot(EYS_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#984EA3") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = EYS)) +
  ggtitle("EYS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
EYS_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/EYS_2090_45_ModelPlot.jpeg", plot = EYS_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/EYS_2090_45_ModelErrorPlot.jpeg", plot = EYS_2090_ModelErrorPlot, width = 8, height = 6)
```

# RHM

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- RHM
y <- CR_WaterTemp$RHM
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$RHM
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
RHM_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we RHM use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
RHM_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(RHM_out_params)
gelman.diag(RHM_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starting from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(RHM_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it RHM be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  RHM_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you RHM use this data frame with ggplot2
RHMModelPlot <- ggplot(RHM_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#FF7F00")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = RHM)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
RHMModelPlot

RHMModelErrorPlot <- ggplot(RHM_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FF7F00") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = RHM)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
RHMModelErrorPlot

ggsave("Output/GeoSNAP/RHM_45_ModelPlot.jpeg", plot = RHMModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/RHM_45_ModelErrorPlot.jpeg", plot = RHMModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
RHMMod <- RHM_OutputCheck
write.csv(RHMMod, file = "RHMMod_45.csv", row.names = F)
RHM_NSE <- NSE(RHMMod$`50%`, RHM_OutputCheck$RHM, na.rm = TRUE)
RHM_NSE

# filter to data before 2020 for the obs graph?
RHMMod_total <- RHMMod

RHMMod <- RHMMod %>%
  filter(date < "2021-01-01")
range(RHMMod$date)
avgRHM2010 <- mean(RHMMod$`50%`)
avgRHM2010
stdRHM2010 <- sd(RHMMod$`50%`)
stdRHM2010

RHMModelErrorPlot <- ggplot(RHMMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FF7F00") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = RHM)) +
  ggtitle("RHM - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.999")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
RHMModelErrorPlot

ggsave("Output/GeoSNAP/RHM_ObsModelPlot_45.jpeg", plot = RHMModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we RHM zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
RHM_2030 <- RHM_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgRHM2030 <- mean(RHM_2030$`50%`)
avgRHM2030
stdRHM2030 <- sd(RHM_2030$`50%`)
stdRHM2030

# Now you RHM use this data frame with ggplot2
RHM_2030_ModelPlot <- ggplot(RHM_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = RHM)) +
  ggtitle("RHM - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
RHM_2030_ModelPlot

RHM_2030_ModelErrorPlot <- ggplot(RHM_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FF7F00") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = RHM)) +
  ggtitle("RHM - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
RHM_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/RHM_2030_45_ModelPlot.jpeg", plot = RHM_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/RHM_2030_45_ModelErrorPlot.jpeg", plot = RHM_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
RHM_2060 <- RHM_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgRHM2060 <- mean(RHM_2060$`50%`)
avgRHM2060
stdRHM2060 <- sd(RHM_2060$`50%`)
stdRHM2060

# Now you RHM use this data frame with ggplot2
RHM_2060_ModelPlot <- ggplot(RHM_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = RHM)) +
  ggtitle("RHM - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
RHM_2060_ModelPlot

RHM_2060_ModelErrorPlot <- ggplot(RHM_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FF7F00") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = RHM)) +
  ggtitle("RHM - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
RHM_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/RHM_2060_45_ModelPlot.jpeg", plot = RHM_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/RHM_2060_45_ModelErrorPlot.jpeg", plot = RHM_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
RHM_2090 <- RHM_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgRHM2090 <- mean(RHM_2090$`50%`)
avgRHM2090
stdRHM2090 <- sd(RHM_2090$`50%`)
stdRHM2090

# Now you RHM use this data frame with ggplot2
RHM_2090_ModelPlot <- ggplot(RHM_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = RHM)) +
  ggtitle("RHM - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
RHM_2090_ModelPlot

RHM_2090_ModelErrorPlot <- ggplot(RHM_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FF7F00") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = RHM)) +
  ggtitle("RHM - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
RHM_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/RHM_2090_45_ModelPlot.jpeg", plot = RHM_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/RHM_2090_45_ModelErrorPlot.jpeg", plot = RHM_2090_ModelErrorPlot, width = 8, height = 6)
```


# SQR

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- SQR
y <- CR_WaterTemp$SQR
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$SQR
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
SQR_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we SQR use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
SQR_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(SQR_out_params)
gelman.diag(SQR_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starting from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(SQR_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it SQR be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  SQR_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you SQR use this data frame with ggplot2
SQRModelPlot <- ggplot(SQR_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#FFFF33")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = SQR)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
SQRModelPlot

SQRModelErrorPlot <- ggplot(SQR_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FFFF33") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = SQR)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
SQRModelErrorPlot

ggsave("Output/GeoSNAP/SQR_45_ModelPlot.jpeg", plot = SQRModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/SQR_45_ModelErrorPlot.jpeg", plot = SQRModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
SQRMod <- SQR_OutputCheck
write.csv(SQRMod, file = "SQRMod_45.csv", row.names = F)
SQR_NSE <- NSE(SQRMod$`50%`, SQR_OutputCheck$SQR, na.rm = TRUE)
SQR_NSE

# filter to data before 2020 for the obs graph?
SQRMod_total <- SQRMod

SQRMod <- SQRMod %>%
  filter(date < "2021-01-01")
range(SQRMod$date)
avgSQR2010 <- mean(SQRMod$`50%`)
avgSQR2010
stdSQR2010 <- sd(SQRMod$`50%`)
stdSQR2010

SQRModelErrorPlot <- ggplot(SQRMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FFFF33") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = SQR)) +
  ggtitle("SQR - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.933")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
SQRModelErrorPlot

ggsave("Output/GeoSNAP/SQR_ObsModelPlot_45.jpeg", plot = SQRModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we SQR zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
SQR_2030 <- SQR_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgSQR2030 <- mean(SQR_2030$`50%`)
avgSQR2030
stdSQR2030 <- sd(SQR_2030$`50%`)
stdSQR2030

# Now you can use this data frame with ggplot2
SQR_2030_ModelPlot <- ggplot(SQR_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = SQR)) +
  ggtitle("SQR - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
SQR_2030_ModelPlot

SQR_2030_ModelErrorPlot <- ggplot(SQR_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FFFF33") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = SQR)) +
  ggtitle("SQR - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
SQR_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/SQR_2030_45_ModelPlot.jpeg", plot = SQR_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/SQR_2030_45_ModelErrorPlot.jpeg", plot = SQR_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
SQR_2060 <- SQR_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgSQR2060 <- mean(SQR_2060$`50%`)
avgSQR2060
stdSQR2060 <- sd(SQR_2060$`50%`)
stdSQR2060

# Now you can use this data frame with ggplot2
SQR_2060_ModelPlot <- ggplot(SQR_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = SQR)) +
  ggtitle("SQR - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
SQR_2060_ModelPlot

SQR_2060_ModelErrorPlot <- ggplot(SQR_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FFFF33") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = SQR)) +
  ggtitle("SQR - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
SQR_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/SQR_2060_45_ModelPlot.jpeg", plot = SQR_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/SQR_2060_45_ModelErrorPlot.jpeg", plot = SQR_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
SQR_2090 <- SQR_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgSQR2090 <- mean(SQR_2090$`50%`)
avgSQR2090
stdSQR2090 <- sd(SQR_2090$`50%`)
stdSQR2090

# Now you can use this data frame with ggplot2
SQR_2090_ModelPlot <- ggplot(SQR_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = SQR)) +
  ggtitle("SQR - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
SQR_2090_ModelPlot

SQR_2090_ModelErrorPlot <- ggplot(SQR_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#FFFF33") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = SQR)) +
  ggtitle("SQR - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
SQR_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/SQR_2090_45_ModelPlot.jpeg", plot = SQR_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/SQR_2090_45_ModelErrorPlot.jpeg", plot = SQR_2090_ModelErrorPlot, width = 8, height = 6)
```

# TIN

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- TIN
y <- CR_WaterTemp$TIN
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$TIN
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
TIN_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we TIN use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
TIN_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(TIN_out_params)
gelman.diag(TIN_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starting from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(TIN_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it TIN be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  TIN_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you can use this data frame with ggplot2
TINModelPlot <- ggplot(TIN_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#A65628")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIN)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
TINModelPlot

TINModelErrorPlot <- ggplot(TIN_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#A65628") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIN)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
TINModelErrorPlot

ggsave("Output/GeoSNAP/TIN_45_ModelPlot.jpeg", plot = TINModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIN_45_ModelErrorPlot.jpeg", plot = TINModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
TINMod <- TIN_OutputCheck
write.csv(TINMod, file = "TINMod_45.csv", row.names = F)
TIN_NSE <- NSE(TINMod$`50%`, TIN_OutputCheck$TIN, na.rm = TRUE)
TIN_NSE

# filter to data before 2020 for the obs graph?
TINMod_total <- TINMod

TINMod <- TINMod %>%
  filter(date < "2021-01-01")
range(TINMod$date)
avgTIN2010 <- mean(TINMod$`50%`)
avgTIN2010
stdTIN2010 <- sd(TINMod$`50%`)
stdTIN2010

TINModelErrorPlot <- ggplot(TINMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#A65628") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIN)) +
  ggtitle("TIN - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.951")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
TINModelErrorPlot

ggsave("Output/GeoSNAP/TIN_ObsModelPlot_45.jpeg", plot = TINModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we TIN zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
TIN_2030 <- TIN_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgTIN2030 <- mean(TIN_2030$`50%`)
avgTIN2030
stdTIN2030 <- sd(TIN_2030$`50%`)
stdTIN2030

# Now you can use this data frame with ggplot2
TIN_2030_ModelPlot <- ggplot(TIN_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIN)) +
  ggtitle("TIN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIN_2030_ModelPlot

TIN_2030_ModelErrorPlot <- ggplot(TIN_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#A65628") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIN)) +
  ggtitle("TIN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIN_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/TIN_2030_45_ModelPlot.jpeg", plot = TIN_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIN_2030_45_ModelErrorPlot.jpeg", plot = TIN_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
TIN_2060 <- TIN_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgTIN2060 <- mean(TIN_2060$`50%`)
avgTIN2060
stdTIN2060 <- sd(TIN_2060$`50%`)
stdTIN2060

# Now you can use this data frame with ggplot2
TIN_2060_ModelPlot <- ggplot(TIN_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIN)) +
  ggtitle("TIN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIN_2060_ModelPlot

TIN_2060_ModelErrorPlot <- ggplot(TIN_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#A65628") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIN)) +
  ggtitle("TIN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIN_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/TIN_2060_45_ModelPlot.jpeg", plot = TIN_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIN_2060_45_ModelErrorPlot.jpeg", plot = TIN_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
TIN_2090 <- TIN_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgTIN2090 <- mean(TIN_2090$`50%`)
avgTIN2090
stdTIN2090 <- sd(TIN_2090$`50%`)
stdTIN2090

# Now you can use this data frame with ggplot2
TIN_2090_ModelPlot <- ggplot(TIN_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIN)) +
  ggtitle("TIN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIN_2090_ModelPlot

TIN_2090_ModelErrorPlot <- ggplot(TIN_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#A65628") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIN)) +
  ggtitle("TIN - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIN_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/TIN_2090_45_ModelPlot.jpeg", plot = TIN_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIN_2090_45_ModelErrorPlot.jpeg", plot = TIN_2090_ModelErrorPlot, width = 8, height = 6)
```

# TIS

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- TIS
y <- CR_WaterTemp$TIS
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$TIS
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
TIS_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we TIS use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
TIS_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(TIS_out_params)
gelman.diag(TIS_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starTISg from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(TIS_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it TIS be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  TIS_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you TIS use this data frame with ggplot2
TISModelPlot <- ggplot(TIS_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "#F781BF")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIS)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
TISModelPlot

TISModelErrorPlot <- ggplot(TIS_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#F781BF") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIS)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
TISModelErrorPlot

ggsave("Output/GeoSNAP/TIS_45_ModelPlot.jpeg", plot = TISModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIS_45_ModelErrorPlot.jpeg", plot = TISModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
TISMod <- TIS_OutputCheck
write.csv(TISMod, file = "TISMod_45.csv", row.names = F)
TIS_NSE <- NSE(TISMod$`50%`, TIS_OutputCheck$TIS, na.rm = TRUE)
TIS_NSE

# filter to data before 2020 for the obs graph?
TISMod_total <- TISMod

TISMod <- TISMod %>%
  filter(date < "2021-01-01")
range(TISMod$date)
avgTIS2010 <- mean(TISMod$`50%`)
avgTIS2010
stdTIS2010 <- sd(TISMod$`50%`)
stdTIS2010

TISModelErrorPlot <- ggplot(TISMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#F781BF") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIS)) +
  ggtitle("TIS - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.977")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
TISModelErrorPlot

ggsave("Output/GeoSNAP/TIS_ObsModelPlot_45.jpeg", plot = TISModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we TIS zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
TIS_2030 <- TIS_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgTIS2030 <- mean(TIS_2030$`50%`)
avgTIS2030
stdTIS2030 <- sd(TIS_2030$`50%`)
stdTIS2030

# Now you can use this data frame with ggplot2
TIS_2030_ModelPlot <- ggplot(TIS_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIS)) +
  ggtitle("TIS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIS_2030_ModelPlot

TIS_2030_ModelErrorPlot <- ggplot(TIS_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#F781BF") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIS)) +
  ggtitle("TIS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIS_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/TIS_2030_45_ModelPlot.jpeg", plot = TIS_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIS_2030_45_ModelErrorPlot.jpeg", plot = TIS_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
TIS_2060 <- TIS_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgTIS2060 <- mean(TIS_2060$`50%`)
avgTIS2060
stdTIS2060 <- sd(TIS_2060$`50%`)
stdTIS2060

# Now you can use this data frame with ggplot2
TIS_2060_ModelPlot <- ggplot(TIS_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIS)) +
  ggtitle("TIS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIS_2060_ModelPlot

TIS_2060_ModelErrorPlot <- ggplot(TIS_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#F781BF") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIS)) +
  ggtitle("TIS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIS_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/TIS_2060_45_ModelPlot.jpeg", plot = TIS_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIS_2060_45_ModelErrorPlot.jpeg", plot = TIS_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
TIS_2090 <- TIS_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgTIS2090 <- mean(TIS_2090$`50%`)
avgTIS2090
stdTIS2090 <- sd(TIS_2090$`50%`)
stdTIS2090

# Now you can use this data frame with ggplot2
TIS_2090_ModelPlot <- ggplot(TIS_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = TIS)) +
  ggtitle("TIS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIS_2090_ModelPlot

TIS_2090_ModelErrorPlot <- ggplot(TIS_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "#F781BF") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = TIS)) +
  ggtitle("TIS - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
TIS_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/TIS_2090_45_ModelPlot.jpeg", plot = TIS_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/TIS_2090_45_ModelErrorPlot.jpeg", plot = TIS_2090_ModelErrorPlot, width = 8, height = 6)
```

# WDD

Here this is set up as just one pond and temperature data

```{r}
CR_WaterTemp

# Reset row names
rownames(CR_WaterTemp) <- NULL

# pulling out the dates here
time <- CR_WaterTemp$date
length(time)

# Choose one pond to plot through time -- WDD
y <- CR_WaterTemp$WDD
length(y)

# Pull out the air temperature from the data
tempMean <- CR_AirTemp$Air_MonthAvg
length(tempMean)

tempPrecision <- CR_AirTemp$precision
length(tempPrecision)
```

The code itself has three components, the data model, the process model, and the priors.

Data Model - relates the observed data, y, at any time point to the latent variable, x. For this example we'll assume that the observation model just consists of Gaussian observation error.

Process Model - relates the state of the system at one point in time to the state one time step ahead. In this case we'll start with the simplest possible process model, a random walk, which just consists of Gaussian process error centered around the current value of the system.

Priors - Finally, for the priors we need to define **priors** for the initial condition, the process error, and the observation error.

### Setting up the random walk --> added in the air temperature here

Setup Notes -beta0 as a matrix for the intercept and slope -linear relationship between air and water temperature (k = m\*x+b)

```{r}
dlm <- "
model{
#### Priors
x[1] ~ dnorm(x_ic, tau_ic) # Initial condition of water temperature
tau_obs ~ dgamma(a_obs, r_obs) # Prior on observation error
tau_add ~ dgamma(a_add, r_add) # Prior on process error

#### Fixed Effects
beta ~ dmnorm(mu_beta, tau_beta) # prior on beta coefficients

#### Data Model
for(t in 1:n){ # loop over all time steps
OBS[t] ~ dnorm(x[t], tau_obs) # observed water temperature is drawn from latent air temperature with observation uncertainty
Xf[t] ~ dnorm(muAirTemp[t], tauAirTemp[t]) # latent air temperature is drawn from mean and precision of forecasted air temperature
}

#### Process Model
for(t in 2:n){ # loop over all time steps except the first (we defined ic above)
mu[t] <- x[t-1] + beta[1] + beta[2] * x[t-1] + beta[3] * Xf[t] # mean water temperature is a function of the previous time step and current air temperature
x[t] ~ dnorm(mu[t], tau_add) # latent water temperature is drawn from mean water temperature with process uncertainty
}
}
"
```

create precision in the file of the temperatures
     precision = 1/(tempSTD^2)

### Next we need to define the data and priors as a list. and the initial state of the model's parameters for each chain in the MCMC. The overall initialization is stored as a list the same length as the number of chains, where each chain is passed a list of the initial values for each parameter. Unlike the definition of the priors, which had to be done independent of the data, the initialization of the MCMC is allowed (and even encouraged) to use the data. However, each chain should be started from different initial conditions. We handle this below by basing the initial conditions for each chain off of a different random sample of the original data.


```{r}
# Empty list
data <- list()
# Water temperature observations
data$OBS <- CR_WaterTemp$WDD
# Number of time steps
data$n <- length(data$OBS)
# Initial water temperature mean
data$x_ic <- mean(data$OBS, na.rm = TRUE)
# Initial water temperature precision
data$tau_ic = 100
# Prior parameters for observation and process uncertainty
data$a_obs = 1
data$r_obs = 1
data$a_add = 1
data$r_add = 1
# Prior parameters for beta coefficients
data$mu_beta <- c(0, 0, 0)
data$tau_beta <- diag(x = c(0.001, 0.001, 0.001), nrow = 3, ncol = 3)
# Mean air temperature estimate
data$muAirTemp <- CR_AirTemp$Air_MonthAvg
# Air temperature precision
data$tauAirTemp <- CR_AirTemp$precision
```


### Now that we've defined the model, the data, and the initialization, we need to send all this info to JAGS, which will return the JAGS model object.

```{r}
# Create JAGS model with 3 chains
jm <- jags.model(file = textConnection(dlm), data = data, n.chains = 3)
```

### Next, given the defined JAGS model, we'll want to take a few samples from the MCMC chain and assess when the model has converged. To take samples from the MCMC object we'll need to tell JAGS what variables to track and how many samples to take.

```{r}
# Posterior samples of parameters
WDD_out_params <- coda.samples(model = jm,
                               variable.names = c('beta',
                                                  'tau_add', 'tau_obs'),
                               n.iter = 100000, thin = 5)
```

### Since rjags returns the samples as a CODA object, we CAN use any of the diagnostics in the R *coda* library to test for convergence, summarize the output, or visualize the chains.

Now that the model has converged we'll want to take a much larger sample from the MCMC and include the full vector of X's in the output

```{r}
# Posterior samples of response variables
WDD_out_response <- coda.samples(model = jm,
                                 variable.names = c('x', 'OBS'),
                                 n.iter = 100000, thin = 5)

plot(WDD_out_params)
gelman.diag(WDD_out_params, confidence = 0.99)
```

### Given the full joint posterior samples, we're next going to visualize the output by just looking at the **95% credible interval of the time-series of X's** and compare that to the observed Y's. To do so we'll convert the coda output into a matrix and then calculate the quantiles. Looking at colnames(out) will show you that the first two columns are `tau_add` and `tau_obs`, so we calculate the CI starWDDg from the 3rd column. We also transform the samples back from the log domain to the linear domain.

```{r}
time                               ## adjust to zoom in and out
time <-as.Date(time)
out <- as.matrix(WDD_out_response)         ## convert from coda to matrix
x.cols <- grep("^x",colnames(out)) ## grab all columns that start with the letter x
ci <- apply(out[,x.cols], 2, quantile, c(0.025,0.5,0.975))

# changing ci to a dataframe so that it WDD be plotted
  # Load necessary libraries
  library(tidyverse)
  
  # Assuming `ci` is your matrix
  ci_df <- as.data.frame(ci)
  names(ci_df) <- time

  # Transpose the dataframe
  ci_transposed <- as.data.frame(t(ci_df))

  # Change the dates to be a column
  ci_transposed <- rownames_to_column(ci_transposed, var = "date")
  ci_transposed$date <- as.Date(ci_transposed$date)
  
  ModelOutput <- ci_transposed
  
  WDD_OutputCheck <- merge(ModelOutput, CR_WaterTemp, by = "date", all = T)

# Now you WDD use this data frame with ggplot2
WDDModelPlot <- ggplot(WDD_OutputCheck) +
  geom_line(aes(x = date, y = `50%`, color = "lightblue")) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = WDD)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14),
        legend.position = "none")
WDDModelPlot

WDDModelErrorPlot <- ggplot(WDD_OutputCheck, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "lightblue") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = WDD)) +
  geom_vline(xintercept = as.Date("2021-01-01"), color = "red", linetype = "dashed", size = 1) +
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
WDDModelErrorPlot

ggsave("Output/GeoSNAP/WDD_45_ModelPlot.jpeg", plot = WDDModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/WDD_45_ModelErrorPlot.jpeg", plot = WDDModelErrorPlot, width = 8, height = 6)
```
## Calculating the NSE (Nash-Sutcliffe efficiency) between our modeled/simulated values and the observations
```{r}
WDDMod <- WDD_OutputCheck
write.csv(WDDMod, file = "WDDMod_45.csv", row.names = F)
WDD_NSE <- NSE(WDDMod$`50%`, WDD_OutputCheck$WDD, na.rm = TRUE)
WDD_NSE

# filter to data before 2020 for the obs graph?
WDDMod_total <- WDDMod

WDDMod <- WDDMod %>%
  filter(date < "2021-01-01")
range(WDDMod$date)
avgWDD2010 <- mean(WDDMod$`50%`)
avgWDD2010
stdWDD2010 <- sd(WDDMod$`50%`)
stdWDD2010

WDDModelErrorPlot <- ggplot(WDDMod, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "lightblue") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = WDD)) +
  ggtitle("WDD - Copper River Delta")+
  annotate("text", x = as.Date("2020-01-01"), y = 25, label = "NSE = 0.999")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))
WDDModelErrorPlot

ggsave("Output/GeoSNAP/WDD_ObsModelPlot_45.jpeg", plot = WDDModelErrorPlot, width = 8, height = 6)

```

####  Adding code here so that we WDD zoom in on a few decades: 2030s, 2060s, 2090s

1. 2030s
```{r}
# filtering for 2030s
WDD_2030 <- WDD_OutputCheck %>%
  filter(date > "2029-12-01" & date < "2040-01-01")
avgWDD2030 <- mean(WDD_2030$`50%`)
avgWDD2030
stdWDD2030 <- sd(WDD_2030$`50%`)
stdWDD2030

# Now you can use this data frame with ggplot2
WDD_2030_ModelPlot <- ggplot(WDD_2030) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = WDD)) +
  ggtitle("WDD - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
WDD_2030_ModelPlot

WDD_2030_ModelErrorPlot <- ggplot(WDD_2030, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "lightblue") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = WDD)) +
  ggtitle("WDD - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
WDD_2030_ModelErrorPlot

ggsave("Output/GeoSNAP/WDD_2030_45_ModelPlot.jpeg", plot = WDD_2030_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/WDD_2030_45_ModelErrorPlot.jpeg", plot = WDD_2030_ModelErrorPlot, width = 8, height = 6)
```
2. 2060s
```{r}
# filtering for 2030s
WDD_2060 <- WDD_OutputCheck %>%
  filter(date > "2059-12-01" & date < "2070-01-01")
avgWDD2060 <- mean(WDD_2060$`50%`)
avgWDD2060
stdWDD2060 <- sd(WDD_2060$`50%`)
stdWDD2060

# Now you can use this data frame with ggplot2
WDD_2060_ModelPlot <- ggplot(WDD_2060) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = WDD)) +
  ggtitle("WDD - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
WDD_2060_ModelPlot

WDD_2060_ModelErrorPlot <- ggplot(WDD_2060, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "lightblue") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = WDD)) +
  ggtitle("WDD - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
WDD_2060_ModelErrorPlot

ggsave("Output/GeoSNAP/WDD_2060_45_ModelPlot.jpeg", plot = WDD_2060_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/WDD_2060_45_ModelErrorPlot.jpeg", plot = WDD_2060_ModelErrorPlot, width = 8, height = 6)
```

3. 2090s
````{r}
# filtering for 2030s
WDD_2090 <- WDD_OutputCheck %>%
  filter(date > "2089-12-01" & date < "2100-01-01")
avgWDD2090 <- mean(WDD_2090$`50%`)
avgWDD2090
stdWDD2090 <- sd(WDD_2090$`50%`)
stdWDD2090

# Now you can use this data frame with ggplot2
WDD_2090_ModelPlot <- ggplot(WDD_2090) +
  geom_line(aes(x = date, y = `50%`)) +
  geom_line(aes(x = date, y = `2.5%`)) +
  geom_line(aes(x = date, y = `97.5%`)) +
  geom_point(aes(x = date, y = WDD)) +
  ggtitle("WDD - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
WDD_2090_ModelPlot

WDD_2090_ModelErrorPlot <- ggplot(WDD_2090, mapping = aes(date)) +
  geom_line(mapping = aes(y = `2.5%`)) +
  geom_line(mapping = aes(y = `97.5%`)) +
  geom_ribbon(mapping = aes(ymin = `2.5%`, ymax = `97.5%`), fill = "lightblue") +
  geom_line(aes(x = date, y = `50%`), color = "black") +
  geom_point(aes(x = date, y = WDD)) +
  ggtitle("WDD - Copper River Delta - RCP 4.5")+
  ylim(c(-10, 30))+
  ylab("Temeprature (C)") +
  xlab("Year") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5))
WDD_2090_ModelErrorPlot

ggsave("Output/GeoSNAP/WDD_2090_45_ModelPlot.jpeg", plot = WDD_2090_ModelPlot, width = 8, height = 6)
ggsave("Output/GeoSNAP/WDD_2090_45_ModelErrorPlot.jpeg", plot = WDD_2090_ModelErrorPlot, width = 8, height = 6)
```

# Graphing results

## Attempt by decades

### 2030s 

#### Minimum
```{r}
# setting up the dataframe here

CR_45_2030 <- BVS_2030
str(CR_45_2030)

CR_45_2030 <- CR_45_2030 %>%
  select(date, BVS, CAB, CAN, EYS, RHM, SQR, TIN, TIS, WDD) %>%
  dplyr::rename(BVS_min = BVS) %>%
  dplyr::rename(CAB_min = CAB) %>%
  dplyr::rename(CAN_min = CAN) %>%
  dplyr::rename(EYS_min = EYS) %>%
  dplyr::rename(RHM_min = RHM) %>%
  dplyr::rename(SQR_min = SQR) %>%
  dplyr::rename(TIN_min = TIN) %>%
  dplyr::rename(TIS_min = TIS) %>%
  dplyr::rename(WDD_min = WDD) 
str(CR_45_2030)

attr(CR_45_2030, 'row.names') <- 1:nrow(BVS_2030)

test <- CR_45_2030

test$date <- BVS_2030$date
test$BVS_min <- BVS_2030$`2.5%`
test$CAB_min <- CAB_2030$`2.5%`
test$CAN_min <- CAN_2030$`2.5%`
test$EYS_min <- EYS_2030$`2.5%`
test$RHM_min <- RHM_2030$`2.5%`
test$SQR_min <- SQR_2030$`2.5%`
test$TIN_min <- TIN_2030$`2.5%`
test$TIS_min <- TIS_2030$`2.5%`
test$WDD_min <- WDD_2030$`2.5%`

str(test)
CR_45_2030 <- test
rm(test)

# pivoting this longer so there is one column for mean here library(tidyr)

# Assuming your dataframe is named 'test'
test_long <- pivot_longer(CR_45_2030, cols = -date, names_to = "Location", values_to = "Min_Temp")

# Preview the pivoted data
head(test_long)
str(test_long)

CRD_2030_long <- test_long
str(CRD_2030_long)

```

#### Mean

```{r}
CR_45_2030 <- BVS_2030[0,]
str(CR_45_2030)

CR_45_2030 <- CR_45_2030 %>%
  select(date, BVS, CAB, CAN, EYS, RHM, SQR, TIN, TIS, WDD) %>%
  dplyr::rename(BVS_mean = BVS) %>%
  dplyr::rename(CAB_mean = CAB) %>%
  dplyr::rename(CAN_mean = CAN) %>%
  dplyr::rename(EYS_mean = EYS) %>%
  dplyr::rename(RHM_mean = RHM) %>%
  dplyr::rename(SQR_mean = SQR) %>%
  dplyr::rename(TIN_mean = TIN) %>%
  dplyr::rename(TIS_mean = TIS) %>%
  dplyr::rename(WDD_mean = WDD) 
str(CR_45_2030)

attr(CR_45_2030, 'row.names') <- 1:nrow(BVS_2030)

test <- CR_45_2030

test$date <- BVS_2030$date
test$BVS_mean <- BVS_2030$`50%`
test$CAB_mean <- CAB_2030$`50%`
test$CAN_mean <- CAN_2030$`50%`
test$EYS_mean <- EYS_2030$`50%`
test$RHM_mean <- RHM_2030$`50%`
test$SQR_mean <- SQR_2030$`50%`
test$TIN_mean <- TIN_2030$`50%`
test$TIS_mean <- TIS_2030$`50%`
test$WDD_mean <- WDD_2030$`50%`

str(test)

CR_45_2030 <- test

# pivoting this longer so there is one column for mean here library(tidyr)
# Assuming your dataframe is named 'test'
test_long <- pivot_longer(CR_45_2030, cols = -date, names_to = "Location", values_to = "Mean_Temp")

# Preview the pivoted data
head(test_long)
str(test_long)

CRD_2030_long$Mean_Temp <- test_long$Mean_Temp
str(CRD_2030_long)

rm(test, test_long)
```

#### Maximum

```{r}
CR_45_2030 <- BVS_2030[0,]
str(CR_45_2030)

CR_45_2030 <- CR_45_2030 %>%
  select(date, BVS, CAB, CAN, EYS, RHM, SQR, TIN, TIS, WDD) %>%
  dplyr::rename(BVS_max = BVS) %>%
  dplyr::rename(CAB_max = CAB) %>%
  dplyr::rename(CAN_max = CAN) %>%
  dplyr::rename(EYS_max = EYS) %>%
  dplyr::rename(RHM_max = RHM) %>%
  dplyr::rename(SQR_max = SQR) %>%
  dplyr::rename(TIN_max = TIN) %>%
  dplyr::rename(TIS_max = TIS) %>%
  dplyr::rename(WDD_max = WDD) 
str(CR_45_2030)

attr(CR_45_2030, 'row.names') <- 1:nrow(BVS_2030)

test <- CR_45_2030

test$date <- BVS_2030$date
test$BVS_max <- BVS_2030$`97.5%`
test$CAB_max <- CAB_2030$`97.5%`
test$CAN_max <- CAN_2030$`97.5%`
test$EYS_max <- EYS_2030$`97.5%`
test$RHM_max <- RHM_2030$`97.5%`
test$SQR_max <- SQR_2030$`97.5%`
test$TIN_max <- TIN_2030$`97.5%`
test$TIS_max <- TIS_2030$`97.5%`
test$WDD_max <- WDD_2030$`97.5%`

str(test)

CR_45_2030 <- test

# pivoting this longer so there is one column for mean here library(tidyr)
# Assuming your dataframe is named 'test'
test_long <- pivot_longer(CR_45_2030, cols = -date, names_to = "Location", values_to = "Max_Temp")

# Preview the pivoted data
head(test_long)
str(test_long)

CRD_2030_long$Max_Temp <- test_long$Max_Temp
str(CRD_2030_long)

rm(test, test_long)

```

#### Attemping a graph of this

Create a column for month
```{R}
str(CR_45_2030)

test <- CR_45_2030 %>%
  mutate(month = month(date))

```

### 2060s 

#### Minimum
```{r}
# setting up the dataframe here

CR_45_2060 <- CR_45_2030[0,]
str(CR_45_2060)


attr(CR_45_2060, 'row.names') <- 1:nrow(BVS_2060)

test <- CR_45_2060

test$date <- BVS_2060$date
test$BVS_min <- BVS_2060$`2.5%`
test$CAB_min <- CAB_2060$`2.5%`
test$CAN_min <- CAN_2060$`2.5%`
test$EYS_min <- EYS_2060$`2.5%`
test$RHM_min <- RHM_2060$`2.5%`
test$SQR_min <- SQR_2060$`2.5%`
test$TIN_min <- TIN_2060$`2.5%`
test$TIS_min <- TIS_2060$`2.5%`
test$WDD_min <- WDD_2060$`2.5%`

str(test)
CR_45_2060 <- test
rm(test)
```

#### Mean

```{r}
test <- CR_45_2060

test$BVS_mean <- BVS_2060$`50%`
test$CAB_mean <- CAB_2060$`50%`
test$CAN_mean <- CAN_2060$`50%`
test$EYS_mean <- EYS_2060$`50%`
test$RHM_mean <- RHM_2060$`50%`
test$SQR_mean <- SQR_2060$`50%`
test$TIN_mean <- TIN_2060$`50%`
test$TIS_mean <- TIS_2060$`50%`
test$WDD_mean <- WDD_2060$`50%`

str(test)

CR_45_2060 <- test
rm(test)
```

#### Maximum

```{r}
test <- CR_45_2060

test$BVS_max <- BVS_2060$`97.5%`
test$CAB_max <- CAB_2060$`97.5%`
test$CAN_max <- CAN_2060$`97.5%`
test$EYS_max <- EYS_2060$`97.5%`
test$RHM_max <- RHM_2060$`97.5%`
test$SQR_max <- SQR_2060$`97.5%`
test$TIN_max <- TIN_2060$`97.5%`
test$TIS_max <- TIS_2060$`97.5%`
test$WDD_max <- WDD_2060$`97.5%`

str(test)

CR_45_2060 <- test
rm(test)
```

### 2090s 

#### Minimum
```{r}
# setting up the dataframe here

CR_45_2090 <- CR_45_2060[0,]
str(CR_45_2090)

attr(CR_45_2090, 'row.names') <- 1:nrow(BVS_2090)

test <- CR_45_2090

test$date <- BVS_2090$date
test$BVS_min <- BVS_2090$`2.5%`
test$CAB_min <- CAB_2090$`2.5%`
test$CAN_min <- CAN_2090$`2.5%`
test$EYS_min <- EYS_2090$`2.5%`
test$RHM_min <- RHM_2090$`2.5%`
test$SQR_min <- SQR_2090$`2.5%`
test$TIN_min <- TIN_2090$`2.5%`
test$TIS_min <- TIS_2090$`2.5%`
test$WDD_min <- WDD_2090$`2.5%`

str(test)
CR_45_2090 <- test
rm(test)
```

#### Mean

```{r}
test <- CR_45_2090

test$BVS_mean <- BVS_2090$`50%`
test$CAB_mean <- CAB_2090$`50%`
test$CAN_mean <- CAN_2090$`50%`
test$EYS_mean <- EYS_2090$`50%`
test$RHM_mean <- RHM_2090$`50%`
test$SQR_mean <- SQR_2090$`50%`
test$TIN_mean <- TIN_2090$`50%`
test$TIS_mean <- TIS_2090$`50%`
test$WDD_mean <- WDD_2090$`50%`

str(test)

CR_45_2090 <- test
rm(test)
```

#### Maximum

```{r}
test <- CR_45_2090

test$BVS_max <- BVS_2090$`97.5%`
test$CAB_max <- CAB_2090$`97.5%`
test$CAN_max <- CAN_2090$`97.5%`
test$EYS_max <- EYS_2090$`97.5%`
test$RHM_max <- RHM_2090$`97.5%`
test$SQR_max <- SQR_2090$`97.5%`
test$TIN_max <- TIN_2090$`97.5%`
test$TIS_max <- TIS_2090$`97.5%`
test$WDD_max <- WDD_2090$`97.5%`

str(test)

CR_45_2090 <- test
rm(test)
```


## Attempt as a whole?

### Mean

#### 2030

```{r}
CR_45_2030 <- BVS_2030[0,]
str(CR_45_2030)

CR_45_2030 <- CR_45_2030 %>%
  select(date, BVS, CAB, CAN, EYS, RHM, SQR, TIN, TIS, WDD) %>%
  dplyr::rename(BVS_mean = BVS) %>%
  dplyr::rename(CAB_mean = CAB) %>%
  dplyr::rename(CAN_mean = CAN) %>%
  dplyr::rename(EYS_mean = EYS) %>%
  dplyr::rename(RHM_mean = RHM) %>%
  dplyr::rename(SQR_mean = SQR) %>%
  dplyr::rename(TIN_mean = TIN) %>%
  dplyr::rename(TIS_mean = TIS) %>%
  dplyr::rename(WDD_mean = WDD) 
str(CR_45_2030)

attr(CR_45_2030, 'row.names') <- 1:nrow(BVS_2030)

test <- CR_45_2030

test$date <- BVS_2030$date
test$BVS_mean <- BVS_2030$`50%`
test$CAB_mean <- CAB_2030$`50%`
test$CAN_mean <- CAN_2030$`50%`
test$EYS_mean <- EYS_2030$`50%`
test$RHM_mean <- RHM_2030$`50%`
test$SQR_mean <- SQR_2030$`50%`
test$TIN_mean <- TIN_2030$`50%`
test$TIS_mean <- TIS_2030$`50%`
test$WDD_mean <- WDD_2030$`50%`

str(test)

CR_45_2030 <- test

# pivoting this longer so there is one column for mean here library(tidyr)
# Assuming your dataframe is named 'test'
test_long <- pivot_longer(CR_45_2030, cols = -date, names_to = "Location", values_to = "Mean2030_Temp")

# Preview the pivoted data
head(test_long)
str(test_long)

CRD_Mean_long<- test_long
str(CRD_Mean_long)

rm(test, test_long)
```
#### 2060

```{r}

CR_45_2060 <- BVS_2060[0,]
str(CR_45_2060)

CR_45_2060 <- CR_45_2060 %>%
  select(date, BVS, CAB, CAN, EYS, RHM, SQR, TIN, TIS, WDD) %>%
  dplyr::rename(BVS_mean = BVS) %>%
  dplyr::rename(CAB_mean = CAB) %>%
  dplyr::rename(CAN_mean = CAN) %>%
  dplyr::rename(EYS_mean = EYS) %>%
  dplyr::rename(RHM_mean = RHM) %>%
  dplyr::rename(SQR_mean = SQR) %>%
  dplyr::rename(TIN_mean = TIN) %>%
  dplyr::rename(TIS_mean = TIS) %>%
  dplyr::rename(WDD_mean = WDD) 
str(CR_45_2060)

attr(CR_45_2060, 'row.names') <- 1:nrow(BVS_2030)

test <- CR_45_2060

test$date <- BVS_2060$date
test$BVS_mean <- BVS_2060$`50%`
test$CAB_mean <- CAB_2060$`50%`
test$CAN_mean <- CAN_2060$`50%`
test$EYS_mean <- EYS_2060$`50%`
test$RHM_mean <- RHM_2060$`50%`
test$SQR_mean <- SQR_2060$`50%`
test$TIN_mean <- TIN_2060$`50%`
test$TIS_mean <- TIS_2060$`50%`
test$WDD_mean <- WDD_2060$`50%`

str(test)

CR_45_2060 <- test

# pivoting this longer so there is one column for mean here library(tidyr)
# Assuming your dataframe is named 'test'
test_long <- pivot_longer(CR_45_2060, cols = -date, names_to = "Location", values_to = "Mean2060_Temp")

# Preview the pivoted data
head(test_long)
str(test_long)

CRD_Mean_long$Mean2060_Temp <- test_long$Mean2060_Temp
str(CRD_Mean_long)

rm(test, test_long)
```

#### 2090

```{r}

CR_45_2090 <- BVS_2090[0,]
str(CR_45_2090)

CR_45_2090 <- CR_45_2090 %>%
  select(date, BVS, CAB, CAN, EYS, RHM, SQR, TIN, TIS, WDD) %>%
  dplyr::rename(BVS_mean = BVS) %>%
  dplyr::rename(CAB_mean = CAB) %>%
  dplyr::rename(CAN_mean = CAN) %>%
  dplyr::rename(EYS_mean = EYS) %>%
  dplyr::rename(RHM_mean = RHM) %>%
  dplyr::rename(SQR_mean = SQR) %>%
  dplyr::rename(TIN_mean = TIN) %>%
  dplyr::rename(TIS_mean = TIS) %>%
  dplyr::rename(WDD_mean = WDD) 
str(CR_45_2090)

attr(CR_45_2090, 'row.names') <- 1:nrow(BVS_2090)

test <- CR_45_2090

test$date <- BVS_2090$date
test$BVS_mean <- BVS_2090$`50%`
test$CAB_mean <- CAB_2090$`50%`
test$CAN_mean <- CAN_2090$`50%`
test$EYS_mean <- EYS_2090$`50%`
test$RHM_mean <- RHM_2090$`50%`
test$SQR_mean <- SQR_2090$`50%`
test$TIN_mean <- TIN_2090$`50%`
test$TIS_mean <- TIS_2090$`50%`
test$WDD_mean <- WDD_2090$`50%`

str(test)

CR_45_2090 <- test

# pivoting this longer so there is one column for mean here library(tidyr)
# Assuming your dataframe is named 'test'
test_long <- pivot_longer(CR_45_2090, cols = -date, names_to = "Location", values_to = "Mean2090_Temp")

# Preview the pivoted data
head(test_long)
str(test_long)

CRD_Mean_long$Mean2090_Temp <- test_long$Mean2090_Temp
str(CRD_Mean_long)

rm(test, test_long)
```

####Getting monthly stats

```{r}
monthly_stats <- CRD_Mean_long %>%
  dplyr::mutate(Month = format(date, "%m")) %>%
  dplyr::group_by(Month) %>%
  dplyr::summarise(
    Mean2030 = mean(Mean2030_Temp),
    Std2030 = sd(Mean2030_Temp),
    Mean2060 = mean(Mean2060_Temp),
    Std2060 = sd(Mean2060_Temp),
    Mean2090 = mean(Mean2090_Temp),
    Std2090 = sd(Mean2090_Temp),
  )

# Preview the resulting dataframe
str(monthly_stats)

# Reshape the tibble
monthly_stats_long <- monthly_stats %>%
  pivot_longer(cols = -Month, 
               names_to = c(".value", "year"), 
               names_sep = "(?<=[A-Za-z])(?=[0-9])")

# Print the reshaped tibble
print(monthly_stats_long)

ggplot(data = monthly_stats_long, aes(x = Month, y = Mean, fill = year))+
  geom_col(position = "dodge")

CRD_45_Mean <- ggplot(data = monthly_stats_long, aes(x = Month, y = Mean, fill = year)) +
  geom_col(position = "dodge") +
  geom_errorbar(aes(ymin = Mean - Std, ymax = Mean + Std), 
                position = "dodge") +
  geom_hline(yintercept = 20, color = "red") +
  ylim(-5,30) +
  labs(fill = "Year", x = "Month", y = "Mean Forecast Temperature (C)") +
  theme_classic() +
  theme(legend.text = element_text(size = 14), legend.title = element_text(size = 15),
        axis.text = element_text(size = 14), axis.title = element_text(size = 16))
CRD_45_Mean

ggsave("Output/GeoSNAP/CRD_45_Mean.jpeg", plot = CRD_45_Mean, width = 9, height = 6)
```

# Plot each pond into the future
```{r}
CR_45_Mod <- data.frame(date = BVSMod_total$date)

CR_45_Mod$BVS <- BVSMod_total$`50%`
CR_45_Mod$CAB <- CABMod_total$`50%`
CR_45_Mod$CAN <- CANMod_total$`50%`
CR_45_Mod$EYS <- EYSMod_total$`50%`
CR_45_Mod$RHM <- RHMMod_total$`50%`
CR_45_Mod$SQR <- SQRMod_total$`50%`
CR_45_Mod$TIN <- TINMod_total$`50%`
CR_45_Mod$TIS <- TISMod_total$`50%`
CR_45_Mod$WDD <- WDDMod_total$`50%`

ggplot(data = CR_45_Mod, aes(x = date)) +
  geom_line(aes(y = BVS, color = "#E41A1C")) +
  geom_line(aes(y = CAB, color = "#377EB8")) +
  geom_line(aes(y = CAN, color = "#4DAF4A")) +
  geom_line(aes(y = EYS, color = "#984EA3")) +
  geom_line(aes(y = RHM, color = "#FF7F00")) +
  geom_line(aes(y = SQR, color = "#FFFF33")) +
  geom_line(aes(y = TIN, color = "#A65628")) +
  geom_line(aes(y = TIS, color = "#F781BF")) +
  geom_line(aes(y = WDD, color = "lightblue")) +
  xlab("Date") +
  ylab("Temperature (C)") +
  theme_bw()


library(reshape)
meltdf <- melt(CR_45_Mod, id.vars ="date")
meltdf <- meltdf %>%
  dplyr::rename(Pond = variable)

# Define your custom colors
custom_colors <- c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", 
                   "#FFFF33", "#A65628", "#F781BF", "lightblue")

# CReate the plot
IndPonds_Full_CR45 <- ggplot(data = meltdf, aes(x = date, y = value, color = Pond)) +
  geom_line(size = 0.3) +
  facet_wrap(~Pond) +
  scale_color_manual(values = custom_colors) +
  theme_bw()
IndPonds_Full_CR45

ggsave("Output/GeoSNAP/IndPonds_Full_CR45.jpeg", plot = IndPonds_Full_CR45, width = 9, height = 6)

ggplot(data = meltdf, aes(x = date)) +
  stat_smooth(aes(y = value), size = 0.3) +
  facet_wrap(~Pond) +
  theme_bw()

ggplot(data = meltdf, aes(x = date)) +
  geom_line(aes(y = value), size = 0.3)+
  theme_bw()

IndPonds_CR45 <- ggplot(data = meltdf, aes(x = date)) +
  stat_smooth(aes(y = value, color = Pond, fill = Pond), alpha = 0.15, size = 1) +
  scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00","#FFFF33", "#A65628", "#F781BF", "lightblue")) +
  scale_fill_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00","#FFFF33", "#A65628", "#F781BF", "lightblue")) +
  ggtitle("Mean Annual Temperature") +
  xlab("Year") +
  ylab("Temperature (C)") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, size = 18),
        axis.title = element_text(size = 16),
        axis.text = element_text(size = 14))

IndPonds_CR45

ggsave("Output/GeoSNAP/IndPonds_CR45.jpeg", plot = IndPonds_CR45, width = 9, height = 6)

```
